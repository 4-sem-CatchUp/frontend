/**
 * Tests for src/services/profileService.ts - Generated by Coderabbit.
 *
 * Framework: Vitest
 *
 * Coverage:
 * - getProfile: happy path, URL encoding, failure (non-ok), network error, passes AbortSignal
 * - getAchievement: paths & responses, failure conditions
 * - getComment: paths & responses, failure conditions
 * - getActivity: paths & responses, failure conditions
 */

import { describe, test, expect, beforeEach, afterEach, afterAll, vi, type Mock } from 'vitest';
import type { Profile, Achievement, Comment, Activity } from '@/types/types';

// Functions under test
import { getProfile, getAchievement, getComment, getActivity } from './profileService';

// Save original fetch
const originalFetch = globalThis.fetch;

function mockFetchOnce(response: (Partial<Response> & { json?: () => any }) | Promise<any>) {
  (globalThis.fetch as Mock).mockResolvedValue({
    ok: true,
    status: 200,
    statusText: 'OK',
    json: async () => ({}),
    ...response,
  } as unknown as Response);
}

describe('profileService API wrappers', () => {
  beforeEach(() => {
    globalThis.fetch = vi.fn();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  afterAll(() => {
    // Restore original fetch
    globalThis.fetch = originalFetch;
  });

  describe('getProfile', () => {
    test('calls correct URL and returns parsed Profile on success', async () => {
      const username = 'alice';
      const expected: Profile = { username: 'alice' } as unknown as Profile;
      mockFetchOnce({ json: async () => expected });

      const ac = new AbortController();
      const result = await getProfile(username, ac.signal);

      expect(globalThis.fetch).toHaveBeenCalledTimes(1);
      const [url, options] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit];
      expect(url).toBe(`/api/profile/${encodeURIComponent(username)}`);
      expect(options).toMatchObject({ signal: ac.signal });

      expect(result).toEqual(expected);
    });

    test('encodes username with special characters', async () => {
      const username = 'John Doe/#?&';
      const expected: Profile = { username } as unknown as Profile;
      mockFetchOnce({ json: async () => expected });

      const ac = new AbortController();
      await getProfile(username, ac.signal);

      const [url] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit];
      expect(url).toBe(`/api/profile/${encodeURIComponent(username)}`);
    });

    test('throws with status when response not ok', async () => {
      (globalThis.fetch as Mock).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        json: async () => ({ message: 'boom' }),
      });

      const ac = new AbortController();
      await expect(getProfile('bob', ac.signal)).rejects.toThrow('Profile fetch failed: 500');
    });

    test('propagates network errors (fetch rejection)', async () => {
      (globalThis.fetch as Mock).mockRejectedValue(new Error('network down'));
      const ac = new AbortController();

      await expect(getProfile('netfail', ac.signal)).rejects.toThrow('network down');
    });
  });

  describe('getAchievement', () => {
    test('hits /achievement and returns achievements on success', async () => {
      const username = 'achiever';
      const expected: Achievement[] = [{ id: '1', title: 'Trophy' } as unknown as Achievement];
      mockFetchOnce({ json: async () => expected });

      const ac = new AbortController();
      const result = await getAchievement(username, ac.signal);

      expect(globalThis.fetch).toHaveBeenCalledTimes(1);
      const [url, options] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit];
      expect(url).toBe(`/api/profile/${encodeURIComponent(username)}/achievement`);
      expect(options).toMatchObject({ signal: ac.signal });

      expect(result).toEqual(expected);
    });

    test('throws error with status when response not ok', async () => {
      (globalThis.fetch as Mock).mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        json: async () => ({}),
      });

      const ac = new AbortController();
      await expect(getAchievement('missing', ac.signal)).rejects.toThrow('Achievement fetch failed: 404');
    });

    test('propagates network errors', async () => {
      (globalThis.fetch as Mock).mockRejectedValue(new Error('connect ETIMEDOUT'));
      const ac = new AbortController();

      await expect(getAchievement('slow', ac.signal)).rejects.toThrow('connect ETIMEDOUT');
    });
  });

  describe('getComment', () => {
    test('hits /comment and returns comments on success', async () => {
      const username = 'commenter';
      const expected: Comment[] = [{ id: 'c1', body: 'Nice!' } as unknown as Comment];
      mockFetchOnce({ json: async () => expected });

      const ac = new AbortController();
      const result = await getComment(username, ac.signal);

      expect(globalThis.fetch).toHaveBeenCalledTimes(1);
      const [url, options] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit];
      expect(url).toBe(`/api/profile/${encodeURIComponent(username)}/comment`);
      expect(options).toMatchObject({ signal: ac.signal });

      expect(result).toEqual(expected);
    });

    test('throws error with status when response not ok', async () => {
      (globalThis.fetch as Mock).mockResolvedValue({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        json: async () => ({}),
      });

      const ac = new AbortController();
      await expect(getComment('private', ac.signal)).rejects.toThrow('Comment fetch failed: 401');
    });

    test('propagates network errors', async () => {
      (globalThis.fetch as Mock).mockRejectedValue(new Error('ECONNRESET'));
      const ac = new AbortController();

      await expect(getComment('reset', ac.signal)).rejects.toThrow('ECONNRESET');
    });
  });

  describe('getActivity', () => {
    test('hits /activity and returns activities on success', async () => {
      const username = 'activeUser';
      const expected: Activity[] = [{ id: 'a1', type: 'login' } as unknown as Activity];
      mockFetchOnce({ json: async () => expected });

      const ac = new AbortController();
      const result = await getActivity(username, ac.signal);

      expect(globalThis.fetch).toHaveBeenCalledTimes(1);
      const [url, options] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit];
      expect(url).toBe(`/api/profile/${encodeURIComponent(username)}/activity`);
      expect(options).toMatchObject({ signal: ac.signal });

      expect(result).toEqual(expected);
    });

    test('throws error with status when response not ok', async () => {
      (globalThis.fetch as Mock).mockResolvedValue({
        ok: false,
        status: 503,
        statusText: 'Service Unavailable',
        json: async () => ({}),
      });

      const ac = new AbortController();
      await expect(getActivity('downtime', ac.signal)).rejects.toThrow('Activity fetch failed: 503');
    });

    test('propagates network errors', async () => {
      (globalThis.fetch as Mock).mockRejectedValue(new Error('DNS lookup failed'));
      const ac = new AbortController();

      await expect(getActivity('dns', ac.signal)).rejects.toThrow('DNS lookup failed');
    });
  });

  describe('defensive inputs', () => {
    test('empty username is still encoded correctly and requested', async () => {
      const expected: Profile = { username: '' } as unknown as Profile;
      mockFetchOnce({ json: async () => expected });

      const ac = new AbortController();
      await getProfile('', ac.signal);

      const [url] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit]; 
      expect(url).toBe('/api/profile/');
    });

    test('username containing slashes is properly encoded (no path traversal)', async () => {
      const tricky = '../admin/root';
      mockFetchOnce({ json: async () => ({}) });

      const ac = new AbortController();
      await getComment(tricky, ac.signal);

      const [url] = (globalThis.fetch as Mock).mock.calls[0] as [string, RequestInit];
      expect(url).toBe(`/api/profile/${encodeURIComponent(tricky)}/comment`);
      expect(url.includes('../')).toBe(false);
      expect(url.includes('/admin')).toBe(false);
    });
  });
});
